### 문제 풀이
- 테스트 케이스의 수는 100개 이하
- 지도의 높이와 너비 h와 w (2 ≤ h, w ≤ 100)
- '.'는 빈 공간,*'는 벽,'$'는 상근이가 훔쳐야하는 문서,알파벳 대문자는 문,알파벳 소문자는 열쇠를 나타낸다.
- 빌딩의 문은 모두 잠겨있다.
- 소문자 열쇠로 해당하는 대문자인 문을 열수있다.
- 상근이가 훔칠 수 있는 문서의 최대 갯수를 출력하여라
- 상근이의 위치는 정해져 있지 않다.


#### 순서
- 외부에서 시작하기 때문에 입력 받을 시에 1~h, 1~w 부분만 입력 받는다. (0과 h+1,w+1은 들어가는 출입문으로 생각한다.)
- BFS를 돌면서 '$'면 카운팅하고 중복 탐색을 방지하기 위해 '.'로 바꾸어준다.
- 대문자를 만나면 이후에, 열쇠를 발견했을 시에, 한번 탐색 해야함으로 queue에 저장한다.(방문한 대문자를 문을 열 수 있을 때, 다시 탐색하기위해)
- 소문자를 만나면, 문을 열 수 있기에 저장해놨던 대문자 queue(즉, 이전에 방문했던 )를 경로에 추가하면서 queue를 비운다. 모두 재탐색을 위해방문 체크 배열을 초기화한다.






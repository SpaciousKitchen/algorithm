
https://www.acmicpc.net/problem/13460
### 문제 풀이
-  두 정수 N, M (3 ≤ N, M ≤ 10) 각 가로,세로의 크기이다.
- '.', '#', 'O', 'R', 'B' 로 이루어져 있다. '.'은 빈 칸을 의미하고, '#'은 공이 이동할 수 없는 장애물 또는 벽을 의미하며, 'O'는 구멍의 위치를 의미한다. 'R'은 빨간 구슬의 위치, 'B'는 파란 구슬의 위치이다.
- 입력되는 모든 보드의 가장자리에는 모두 '#'이 있다. 구멍의 개수는 한 개 이며, 빨간 구슬과 파란 구슬은 항상 1개가 주어진다.
-  게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다.
- 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다.
- 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다. 빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다.
-  기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다.

- 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 출력한다. 만약, 10번 이하로 움직여서 빨간 구슬을 구멍을 통해 빼낼 수 없으면 -1을 출력한다.
#### 순서
- 상하좌우(4)로 10번 이하 옮직이기에 모든 경우의 수를 다 구하면 3^9*4이므로  완전탐색을 사용할 수 있다.
- 갈 수 있는 모든 경로를 가야 하기 때문에 DFS라고 생각했다.
- BFS로도 충분히 풀 수 있다.
- 사면이 벽이니까 범위 비교가 굳이 필요 없다. #을 만나는 지를 체크하면 된다.
- 이전 방향을 기록해줘야 한다고 생각했는데 체크할 필요가 없다.(이동 할수 없으면 굳이 체크하지 않아도 걸러진다.)
- 한 번에 이동하지 말고 따로따로 이동 해도 된다.(기울이면서 움직이기 때문. 하지만 본인은 그 부분을 생각하지 못해서. pre 값을 저장해 걸러줘야 한다고 생각했다.)
    - 해당 경우에는 둘이 같은 위치로 이동 하지 않도록 걸러줘야한다.
- ~~우선 R가 O으로 갈 수 있는 10번 이하로 움직인 모든 경로(BFS)의 경우를 저장한다.~~
- ~~모든 경로(왼,좌,상,하)를 탐색하면서 B 혼자 혹은 R과 같이 빠지는 경우를 제외하고 카운팅한다.~~
    - 같은 경로이지만,상하좌우의 이동 칸이 달라서 답이 되거나 안될 경우가 있다.


